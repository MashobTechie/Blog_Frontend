DAY 1 and 2
JSX , Component and Props

<!-- What is JSX -->
It stands for Javascript XML. 
It is a syntax extension that allows us to write UI code that is both functional(JS) and familiar(HTML,CSS)

JSX Rules: 
1. return a single root element (wrap everything in a <div> or <>)
2. Use className instead of class 
3. Close all tags including self closing tag like <img>[ <img />], <br> [<br/>]
4. Use curly braces {} to embed JS expressions

Functional Components
Components are simple JS functions that return JSX. 

Props(Properties)
Think of props as a way to pass data from a parent component to a child component. It's how we make our Components reusable and dynamic. 


Introducing useState for Managing State:
Problem: For example, if we want to show a counter that increments every time a button is clicked. Simply changing a variable wont work cos React wont know when to rerender(refresh) the UI.

Solution: The useState hook. 
The useState hook is a special function from React that lets us add a state variable to a functional component. When a state variable changes, React will automatically re-render the new value


Assignment: 
Clean default Vite code.
Create a postList component: Create a new component called PostList.jsx. For now, just have it return a hardcoded list of div elements representing mock blog posts. 

Next:useEffect hook(perform data fetching and display the actual blog from database)

Day 3: 

The Problem with API Calls: 
If we put an API call directly into the component body, it runs every time the component re-renders (which is inefficient and ven wrong).
We need a dedicated place for side effects . 

Mastering UseEffect Hook:
useEffect is React's hook for handling side effects which include data fetching , manual DOM Manipulation, setting up timers, counters etc. 

The 3 modes of useEffect:
1. No array ( Runs on Every Render): 
useEffect(() => {...})
2. Empty Array (Runs only once a mount):
useEffect(() => {...}, [])
This is what we use for fetching initial data. 
3. With dependencies( Runs on Mount and when dependencies change): 
useEffect(() => {...}, [someProp, someState]):
{Used for refetching data when filters change etc}

API_KEY: f9ec0bdf955b4cfba35038923fb7e416
